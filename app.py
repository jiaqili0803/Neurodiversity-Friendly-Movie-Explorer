# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zGsQtWkzXuKD0f7gK6TF-HZnaFcHlxJs
"""

import pandas as pd
import networkx as nx
import plotly.graph_objects as go
import plotly.express as px
from dash import Dash, dcc, html, Input, Output, State, callback_context

# ============================
# 1. Load preprocessed data
# ============================
nodes = pd.read_csv("network_nodes.csv")
edges = pd.read_csv("network_edges.csv")
rating_hist = pd.read_csv("rating_hist.csv")

nodes["id"] = nodes["id"].astype(int)
edges["source"] = edges["source"].astype(int)
edges["target"] = edges["target"].astype(int)
rating_hist["movieId"] = rating_hist["movieId"].astype(int)

# ============================
# 1b. (Optional) Load tags for tooltips
# ============================
try:
    tags_df = pd.read_csv("tags.csv")
    tags_df["tag_clean"] = tags_df["tag"].astype(str).str.lower().str.strip()
    tag_counts = (
        tags_df.dropna(subset=["tag_clean"])
        .groupby(["movieId", "tag_clean"])
        .size()
        .reset_index(name="count")
    )
    top_tags_series = (
        tag_counts.sort_values(["movieId", "count"], ascending=[True, False])
        .groupby("movieId")
        .head(5)
        .groupby("movieId")["tag_clean"]
        .apply(lambda s: ", ".join(s))
    )
    nodes["top_tags"] = nodes["id"].map(top_tags_series).fillna("")
except Exception:
    nodes["top_tags"] = ""

# ============================
# 2. Build graph & layout
# ============================
G = nx.Graph()
for _, row in nodes.iterrows():
    G.add_node(row["id"])

for _, row in edges.iterrows():
    G.add_edge(row["source"], row["target"], weight=row["similarity"])

pos = nx.spring_layout(G, k=0.4, iterations=60, seed=42)
nodes["x"] = nodes["id"].map(lambda mid: pos[mid][0])
nodes["y"] = nodes["id"].map(lambda mid: pos[mid][1])

# Global view ranges (for reset / overview)
x_min, x_max = nodes["x"].min(), nodes["x"].max()
y_min, y_max = nodes["y"].min(), nodes["y"].max()
x_pad = (x_max - x_min) * 0.15 if x_max > x_min else 0.5
y_pad = (y_max - y_min) * 0.15 if y_max > y_min else 0.5
GLOBAL_X_RANGE = [x_min - x_pad, x_max + x_pad]
GLOBAL_Y_RANGE = [y_min - y_pad, y_max + y_pad]

edges_rich = edges.copy()

# ============================
# 3. Visual encodings (colors + shapes)
# ============================

# Distinct genres
unique_genres = sorted(nodes["main_genre"].unique())

# Build a long, mostly non-repeating colorblind-ish palette
base_colors = (
    px.colors.qualitative.Alphabet
    + px.colors.qualitative.Set3
    + px.colors.qualitative.Dark24
)
genre_palette = []
for c in base_colors:
    if c not in genre_palette:
        genre_palette.append(c)

# If somehow we don't have enough colors (unlikely), add greys
if len(genre_palette) < len(unique_genres):
    extra_needed = len(unique_genres) - len(genre_palette)
    greys = [f"#{v:02x}{v:02x}{v:02x}" for v in range(40, 240, 10)]
    genre_palette.extend(greys[:extra_needed])

# Map each genre to a unique color
genre_color_map = {g: genre_palette[i] for i, g in enumerate(unique_genres)}

# Marker shapes per genre (for extra distinguishability)
shape_list = [
    "circle",
    "square",
    "diamond",
    "triangle-up",
    "triangle-down",
    "triangle-left",
    "triangle-right",
    "cross",
    "x",
    "star",
    "hexagon",
    "hexagon2",
]
genre_shape_map = {g: shape_list[i % len(shape_list)] for i, g in enumerate(unique_genres)}

nodes["color"] = nodes["main_genre"].map(genre_color_map)
nodes["shape"] = nodes["main_genre"].map(genre_shape_map)

min_size = 10
max_size = 36
nodes["marker_size"] = min_size + nodes["engagement_norm"] * (max_size - min_size)

TOP_K_SIMPLE = 10
TOP10_IDS = (
    nodes.sort_values("rating_count", ascending=False)["id"]
    .head(TOP_K_SIMPLE)
    .tolist()
)

# ============================
# 4. Helper functions
# ============================
def get_active_ids_simple(focus_id=None):
    """In Simple Mode, show at most TOP_K_SIMPLE active colorful nodes."""
    if focus_id is None:
        return TOP10_IDS
    neighbors = list(G.neighbors(focus_id))
    active = [focus_id] + neighbors
    return active[:TOP_K_SIMPLE]


def compute_centered_axis_ranges(focus_id, span=0.4):
    """Compute ranges for recentering on focus_id; otherwise global."""
    if focus_id is None or focus_id not in nodes["id"].values:
        return GLOBAL_X_RANGE, GLOBAL_Y_RANGE
    row = nodes[nodes["id"] == focus_id].iloc[0]
    cx, cy = row["x"], row["y"]
    return [cx - span, cx + span], [cy - span, cy + span]


def make_network_figure(mode="simple", focus_id=None, search_id=None):
    """
    Build network figure.
    - Simple Mode: <=10 active nodes in color; others as medium-grey background dots.
      Edges always visible between active nodes, with focused edges more visible.
    - Rich Mode: all nodes colored; full similarity network shown.
    - search_id: if not None, that node gets a strong orange halo.
    """
    # ----- Active nodes & edges -----
    if mode == "simple":
        active_ids = set(get_active_ids_simple(focus_id))
        e = edges_rich[
            edges_rich["source"].isin(active_ids)
            & edges_rich["target"].isin(active_ids)
        ]
        base_edge_color = "rgba(156, 163, 175, 0.5)"
        focus_edge_color = "rgba(55, 65, 81, 0.95)"
    else:
        active_ids = set(nodes["id"])
        e = edges_rich
        base_edge_color = "rgba(156, 163, 175, 0.35)"
        focus_edge_color = "rgba(55, 65, 81, 0.85)"

    # ----- Split focus vs non-focus edges -----
    edge_x_focus, edge_y_focus = [], []
    edge_x_other, edge_y_other = [], []
    for _, row in e.iterrows():
        x0, y0 = pos[row["source"]]
        x1, y1 = pos[row["target"]]
        is_focus_edge = (
            focus_id is not None and (row["source"] == focus_id or row["target"] == focus_id)
        )
        if is_focus_edge:
            edge_x_focus += [x0, x1, None]
            edge_y_focus += [y0, y1, None]
        else:
            edge_x_other += [x0, x1, None]
            edge_y_other += [y0, y1, None]

    other_edges_trace = go.Scatter(
        x=edge_x_other,
        y=edge_y_other,
        mode="lines",
        line=dict(width=1, color=base_edge_color),
        hoverinfo="none",
        showlegend=False,
    )
    focus_edges_trace = go.Scatter(
        x=edge_x_focus,
        y=edge_y_focus,
        mode="lines",
        line=dict(width=2.2, color=focus_edge_color),
        hoverinfo="none",
        showlegend=False,
    )

    # ----- Node visuals -----
    xs, ys, colors, sizes, opacities, borders, texts, ids, symbols = [], [], [], [], [], [], [], [], []
    for row in nodes.itertuples():
        mid = row.id
        xs.append(row.x)
        ys.append(row.y)
        ids.append(mid)

        # base: background node (visible but quiet)
        color = "#CBD5E1"   # slate-200
        size = 8
        opacity = 0.6
        border = "rgba(0,0,0,0)"
        symbol = "circle"   # default

        # active nodes in simple / rich modes
        if mid in active_ids:
            color = row.color
            size = row.marker_size
            opacity = 0.95 if mode == "rich" else 0.9
            symbol = getattr(row, "shape", "circle")

        # focus node: subtle enlargement + dark border
        if focus_id is not None and mid == focus_id:
            size *= 1.2
            border = "#111827"

        tags_text = getattr(row, "top_tags", "")
        if not tags_text:
            tags_text = "No tags available"

        texts.append(
            f"<b>{row.label}</b><br>"
            f"Genre: {row.main_genre}<br>"
            f"Avg rating: {row.avg_rating:.2f} / 5<br>"
            f"Ratings: {row.rating_count}<br>"
            f"Key tags: {tags_text}<br>"
            f"<span style='font-size:11px;color:#6B7280;'>"
            f"Recommendations are based on shared genres and user tags with nearby movies."
            f"</span>"
        )
        colors.append(color)
        sizes.append(size)
        opacities.append(opacity)
        borders.append(border)
        symbols.append(symbol)

    node_trace = go.Scatter(
        x=xs,
        y=ys,
        mode="markers",
        hoverinfo="text",
        text=texts,
        marker=dict(
            size=sizes,
            color=colors,
            opacity=opacities,
            symbol=symbols,
            line=dict(width=2, color=borders),
        ),
        customdata=ids,
        showlegend=False,
    )

    traces = [other_edges_trace, focus_edges_trace, node_trace]

    # Extra strong highlight for searched node: orange halo
    if search_id is not None and search_id in nodes["id"].values:
        srow = nodes[nodes["id"] == search_id].iloc[0]
        halo_size = max(float(srow["marker_size"]) * 1.8, 34.0)
        search_highlight = go.Scatter(
            x=[srow["x"]],
            y=[srow["y"]],
            mode="markers",
            marker=dict(
                size=halo_size,
                color="rgba(0,0,0,0)",
                line=dict(width=4, color="#F97316"),
            ),
            hoverinfo="skip",
            showlegend=False,
        )
        traces.append(search_highlight)

    title_text = (
        "Movie Network – Simple Mode (Calm View)"
        if mode == "simple"
        else "Movie Network – Rich Mode (Deep Dive)"
    )

    fig = go.Figure(data=traces)
    fig.update_layout(
        title=title_text,
        title_x=0.5,
        font=dict(family="Arial, sans-serif", size=14),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor="#F9FAFB",
        paper_bgcolor="#F9FAFB",
        hovermode="closest",
        margin=dict(l=10, r=10, t=60, b=10),
    )
    return fig


def make_rating_histogram(focus_id=None):
    """
    Linked histogram:
    - When a movie is in focus (hover/click/search), bar color = node color.
    - Otherwise, default blue.
    """
    if focus_id is None or focus_id not in rating_hist["movieId"].values:
        df = rating_hist.copy()
        title = "Rating Distribution – All Movies in Network"
        bar_color = "#0072B2"
    else:
        df = rating_hist[rating_hist["movieId"] == focus_id].copy()
        movie_row = nodes[nodes["id"] == focus_id].iloc[0]
        movie_title = movie_row["label"]
        bar_color = movie_row["color"]
        title = f"Rating Distribution – {movie_title}"

    df = df.sort_values("rating")
    fig = go.Figure(
        data=[
            go.Bar(
                x=df["rating"],
                y=df["count"],
                marker=dict(color=bar_color),
            )
        ]
    )
    fig.update_layout(
        title=title,
        title_x=0.5,
        font=dict(family="Arial, sans-serif", size=13),
        xaxis_title="Rating (0.5 – 5.0)",
        yaxis_title="Number of Ratings",
        bargap=0.15,
        plot_bgcolor="#FFFFFF",
        paper_bgcolor="#F9FAFB",
        margin=dict(l=40, r=20, t=60, b=40),
    )
    return fig


# ============================
# 5. Dash app layout
# ============================
app = Dash(__name__)
server = app.server  # for Render / gunicorn

app.layout = html.Div(
    style={
        "fontFamily": "Arial, sans-serif",
        "padding": "12px 18px",
        "backgroundColor": "#F3F4F6",
    },
    children=[
        # Store to persist locked focus + last search
        dcc.Store(
            id="focus-store",
            data={"locked_focus_id": None, "last_search_id": None},
        ),

        html.Div(
            [
                html.H2(
                    "Neurodiversity-Friendly Movie Explorer",
                    style={"marginBottom": "4px"},
                ),
                html.Div(
                    "Explore movies by emotional and genre similarity. Simple Mode shows a small, calm neighborhood; Rich Mode reveals the full network.",
                    style={"color": "#4B5563", "fontSize": "14px"},
                ),
            ],
            style={"marginBottom": "10px"},
        ),

        # Controls row
        html.Div(
            [
                html.Span("Display Mode:", style={"marginRight": "8px"}),
                dcc.RadioItems(
                    id="mode-toggle",
                    options=[
                        {"label": " Simple (Calm View)", "value": "simple"},
                        {"label": " Rich (Deep Dive)", "value": "rich"},
                    ],
                    value="simple",
                    inline=True,
                    style={"fontSize": "14px"},
                ),
                html.Span("  |  ", style={"margin": "0 8px"}),
                dcc.Dropdown(
                    id="search-dropdown",
                    options=[
                        {"label": row["label"], "value": int(row["id"])}
                        for _, row in nodes.sort_values("label").iterrows()
                    ],
                    placeholder="Search for a movie…",
                    style={"width": "280px", "display": "inline-block"},
                ),
                html.Button(
                    "Reset View",
                    id="reset-view",
                    n_clicks=0,
                    style={
                        "marginLeft": "10px",
                        "padding": "4px 10px",
                        "borderRadius": "6px",
                        "border": "1px solid #D1D5DB",
                        "backgroundColor": "#FFFFFF",
                        "cursor": "pointer",
                    },
                ),
            ],
            style={
                "marginBottom": "8px",
                "padding": "6px 10px",
                "backgroundColor": "#FFFFFF",
                "borderRadius": "8px",
                "boxShadow": "0 1px 3px rgba(0,0,0,0.06)",
            },
        ),

        # Main two-panel view
        html.Div(
            [
                html.Div(
                    [
                        dcc.Graph(
                            id="network-graph",
                            figure=make_network_figure(
                                mode="simple", focus_id=None, search_id=None
                            ),
                            style={"height": "620px"},
                            config={"displayModeBar": True},
                        )
                    ],
                    style={
                        "width": "65%",
                        "display": "inline-block",
                        "verticalAlign": "top",
                    },
                ),
                html.Div(
                    [
                        dcc.Graph(
                            id="histogram",
                            figure=make_rating_histogram(focus_id=None),
                            style={"height": "620px"},
                            config={"displayModeBar": True},
                        )
                    ],
                    style={
                        "width": "34%",
                        "display": "inline-block",
                        "verticalAlign": "top",
                        "marginLeft": "1%",
                    },
                ),
            ]
        ),

        # Legend + explanation
        html.Div(
            [
                html.H4("What this network shows", style={"marginBottom": "4px"}),
                html.P(
                    "Each circle is a movie. Color and shape together indicate its main genre. "
                    "Lines show similarity based on shared genres and overlapping user tags "
                    "(which often describe mood or emotional themes).",
                    style={"marginBottom": "6px"},
                ),
                html.P(
                    "This network supports tasks like: "
                    "(1) finding similar movies from one you already enjoy, "
                    "(2) discovering nearby genres, and "
                    "(3) comparing how strongly related different recommendations are.",
                    style={"marginBottom": "10px"},
                ),
                html.Div(
                    [
                        # LEFT COLUMN: legend + genre colors
                        html.Div(
                            [
                                html.Div(
                                    "Visual legend",
                                    style={
                                        "fontWeight": "bold",
                                        "marginBottom": "4px",
                                    },
                                ),
                                html.Ul(
                                    [
                                        html.Li(
                                            "Colored + shaped node = movie in the current focus area "
                                            "(up to 10 neighbors in Simple Mode; all movies in Rich Mode)."
                                        ),
                                        html.Li(
                                            "Small grey circle = other movies in the dataset "
                                            "(background context so you never explore in the dark)."
                                        ),
                                        html.Li(
                                            "Node size = how many ratings the movie received "
                                            "(audience engagement)."
                                        ),
                                        html.Li(
                                            "Lines = similarity based on shared genres and shared tags."
                                        ),
                                        html.Li(
                                            "Color + shape together indicate the movie’s main genre "
                                            "(for example, one genre might be a blue circle, another an orange square, another a green diamond)."
                                        ),
                                    ],
                                    style={
                                        "paddingLeft": "18px",
                                        "marginBottom": "6px",
                                    },
                                ),
                                html.Div(
                                    "Genre color key:",
                                    style={
                                        "fontWeight": "bold",
                                        "marginTop": "6px",
                                    },
                                ),
                                html.Div(
                                    [
                                        html.Div(
                                            [
                                                html.Span(
                                                    style={
                                                        "display": "inline-block",
                                                        "width": "10px",
                                                        "height": "10px",
                                                        "borderRadius": "2px",
                                                        "backgroundColor": genre_color_map[g],
                                                        "marginRight": "4px",
                                                    }
                                                ),
                                                html.Span(g),
                                            ],
                                            style={"marginTop": "2px"},
                                        )
                                        for g in unique_genres
                                    ]
                                ),
                            ],
                            style={"flex": "1", "marginRight": "20px"},
                        ),
                        # RIGHT COLUMN: interaction guide
                        html.Div(
                            [
                                html.Div(
                                    "How to interact",
                                    style={
                                        "fontWeight": "bold",
                                        "marginBottom": "4px",
                                    },
                                ),
                                html.Ul(
                                    [
                                        html.Li(
                                            "Hover a movie: see its details and tags, and update the rating histogram color, "
                                            "but the camera does not move."
                                        ),
                                        html.Li(
                                            "Click a movie: lock focus on it and gently recenter/zoom in. "
                                            "After that, hover will not change the focus until you click/search/reset."
                                        ),
                                        html.Li(
                                            "Search for a movie: jump to it, lock focus, and highlight it with an orange halo."
                                        ),
                                        html.Li(
                                            "Use Simple Mode for a calmer view with at most 10 colorful nodes; "
                                            "use Rich Mode to see the full similarity network."
                                        ),
                                        html.Li(
                                            "Use the toolbar or the Reset View button (top) to return to the full overview "
                                            "and clear the current focus."
                                        ),
                                    ],
                                    style={"paddingLeft": "18px"},
                                ),
                            ],
                            style={"flex": "1"},
                        ),
                    ],
                    style={"display": "flex", "flexDirection": "row"},
                ),
            ],
            style={
                "marginTop": "12px",
                "padding": "10px 12px",
                "backgroundColor": "#FFFFFF",
                "borderRadius": "8px",
                "boxShadow": "0 1px 3px rgba(0,0,0,0.06)",
                "fontSize": "13px",
                "color": "#374151",
            },
        ),
    ],
)


# ============================
# 6. Callback: hover + click + search + reset (with focus lock + stable zoom)
# ============================
@app.callback(
    Output("network-graph", "figure"),
    Output("histogram", "figure"),
    Output("focus-store", "data"),
    Input("mode-toggle", "value"),
    Input("network-graph", "hoverData"),
    Input("network-graph", "clickData"),
    Input("search-dropdown", "value"),
    Input("reset-view", "n_clicks"),
    State("focus-store", "data"),
    State("network-graph", "figure"),
)
def update(mode, hoverData, clickData, search_value, reset_clicks, focus_store, current_fig):
    ctx = callback_context
    prop_id_full = ctx.triggered[0]["prop_id"] if ctx.triggered else ""
    prop_id = prop_id_full.split(".")[0] if prop_id_full else ""

    # previous state
    locked_focus_id = None
    last_search_id = None
    if isinstance(focus_store, dict):
        locked_focus_id = focus_store.get("locked_focus_id", None)
        last_search_id = focus_store.get("last_search_id", None)

    focus_id = None
    center_id = None
    search_id_for_halo = last_search_id

    if prop_id == "reset-view":
        # Full reset: no lock, no search, global
        locked_focus_id = None
        last_search_id = None
        focus_id = None
        center_id = None
        search_id_for_halo = None

    elif prop_id == "search-dropdown":
        # Search: lock focus to searched movie
        locked_focus_id = search_value
        last_search_id = search_value
        focus_id = search_value
        center_id = search_value
        search_id_for_halo = search_value

    elif prop_id == "network-graph" and prop_id_full.endswith("clickData"):
        # Click: lock focus to clicked movie, keep last search halo if any
        if clickData and "points" in clickData:
            clicked_id = clickData["points"][0].get("customdata", None)
            locked_focus_id = clicked_id
            focus_id = clicked_id
            center_id = clicked_id
        search_id_for_halo = last_search_id

    elif prop_id == "network-graph" and prop_id_full.endswith("hoverData"):
        # Hover:
        #  - if there is a locked focus, keep using it (hover only changes tooltip)
        #  - if no locked focus, use hovered as focus
        if locked_focus_id is not None:
            focus_id = locked_focus_id
            center_id = None  # NEVER recenter on hover
        else:
            if hoverData and "points" in hoverData:
                hover_id = hoverData["points"][0].get("customdata", None)
                focus_id = hover_id
            center_id = None
        search_id_for_halo = last_search_id

    else:
        # Initial or other triggers: respect locked focus if present
        focus_id = locked_focus_id
        center_id = None
        search_id_for_halo = last_search_id

    # Build network figure
    fig_network = make_network_figure(
        mode=mode,
        focus_id=focus_id,
        search_id=search_id_for_halo,
    )

    # Camera ranges
    if prop_id == "reset-view":
        x_range, y_range = GLOBAL_X_RANGE, GLOBAL_Y_RANGE
    elif center_id is not None:
        # recentre once on click or search
        x_range, y_range = compute_centered_axis_ranges(center_id)
    else:
        # keep whatever range the user is currently at (no jump on hover)
        if current_fig and "layout" in current_fig:
            layout = current_fig.get("layout", {})
            x_range = layout.get("xaxis", {}).get("range", GLOBAL_X_RANGE)
            y_range = layout.get("yaxis", {}).get("range", GLOBAL_Y_RANGE)
        else:
            x_range, y_range = GLOBAL_X_RANGE, GLOBAL_Y_RANGE

    fig_network.update_layout(
        xaxis=dict(range=x_range),
        yaxis=dict(range=y_range),
        transition=dict(duration=450),
    )

    # Linked histogram
    fig_hist = make_rating_histogram(focus_id=focus_id)

    # Updated store
    new_store = {
        "locked_focus_id": locked_focus_id,
        "last_search_id": last_search_id,
    }
    return fig_network, fig_hist, new_store


if __name__ == "__main__":
    app.run(debug=True)

# import pandas as pd
# import networkx as nx
# import plotly.graph_objects as go
# from dash import Dash, dcc, html, Input, Output, State, callback_context

# # preprocessed data

# nodes = pd.read_csv("network_nodes.csv")
# edges = pd.read_csv("network_edges.csv")
# rating_hist = pd.read_csv("rating_hist.csv")

# nodes["id"] = nodes["id"].astype(int)
# edges["source"] = edges["source"].astype(int)
# edges["target"] = edges["target"].astype(int)
# rating_hist["movieId"] = rating_hist["movieId"].astype(int)

# # Load tags for tooltips
# try:
#     tags_df = pd.read_csv("tags.csv")
#     tags_df["tag_clean"] = tags_df["tag"].astype(str).str.lower().str.strip()
#     tag_counts = (
#         tags_df.dropna(subset=["tag_clean"])
#         .groupby(["movieId", "tag_clean"])
#         .size()
#         .reset_index(name="count")
#     )
#     top_tags_series = (
#         tag_counts.sort_values(["movieId", "count"], ascending=[True, False])
#         .groupby("movieId")
#         .head(5)
#         .groupby("movieId")["tag_clean"]
#         .apply(lambda s: ", ".join(s))
#     )
#     nodes["top_tags"] = nodes["id"].map(top_tags_series).fillna("")
# except Exception:
#     nodes["top_tags"] = ""

# # graph & layout

# G = nx.Graph()
# for _, row in nodes.iterrows():
#     G.add_node(row["id"])

# for _, row in edges.iterrows():
#     G.add_edge(row["source"], row["target"], weight=row["similarity"])

# pos = nx.spring_layout(G, k=0.4, iterations=60, seed=42)
# nodes["x"] = nodes["id"].map(lambda mid: pos[mid][0])
# nodes["y"] = nodes["id"].map(lambda mid: pos[mid][1])

# # Global view ranges (for reset / overview)
# x_min, x_max = nodes["x"].min(), nodes["x"].max()
# y_min, y_max = nodes["y"].min(), nodes["y"].max()
# x_pad = (x_max - x_min) * 0.15 if x_max > x_min else 0.5
# y_pad = (y_max - y_min) * 0.15 if y_max > y_min else 0.5
# GLOBAL_X_RANGE = [x_min - x_pad, x_max + x_pad]
# GLOBAL_Y_RANGE = [y_min - y_pad, y_max + y_pad]

# edges_rich = edges.copy()


# # Visual encodings

# okabe_ito = [
#     "#0072B2",  # blue
#     "#E69F00",  # orange
#     "#009E73",  # green
#     "#D55E00",  # vermillion
#     "#CC79A7",  # reddish purple
#     "#F0E442",  # yellow
#     "#56B4E9",  # sky blue
#     "#999999",  # gray
# ]

# unique_genres = sorted(nodes["main_genre"].unique())
# genre_color_map = {g: okabe_ito[i % len(okabe_ito)] for i, g in enumerate(unique_genres)}
# nodes["color"] = nodes["main_genre"].map(genre_color_map)

# min_size = 10
# max_size = 36
# nodes["marker_size"] = min_size + nodes["engagement_norm"] * (max_size - min_size)

# TOP_K_SIMPLE = 10
# TOP10_IDS = (
#     nodes.sort_values("rating_count", ascending=False)["id"]
#     .head(TOP_K_SIMPLE)
#     .tolist()
# )



# # interactive/design functions

# def get_active_ids_simple(focus_id=None):
#     """In Simple Mode, show at most TOP_K_SIMPLE active colorful nodes."""
#     if focus_id is None:
#         return TOP10_IDS
#     neighbors = list(G.neighbors(focus_id))
#     active = [focus_id] + neighbors
#     return active[:TOP_K_SIMPLE]


# def compute_centered_axis_ranges(focus_id, span=0.4):
#     """Compute ranges for recentering on focus_id; otherwise global."""
#     if focus_id is None or focus_id not in nodes["id"].values:
#         return GLOBAL_X_RANGE, GLOBAL_Y_RANGE
#     row = nodes[nodes["id"] == focus_id].iloc[0]
#     cx, cy = row["x"], row["y"]
#     return [cx - span, cx + span], [cy - span, cy + span]


# def make_network_figure(mode="simple", focus_id=None, search_id=None):
#     """
#     Build network figure.
#     - Simple Mode: <=10 active nodes in color; others as medium-grey background dots.
#       Edges always visible between active nodes, with focused edges more visible.
#     - Rich Mode: all nodes colored; full similarity network shown.
#     - search_id: if not None, that node gets a strong orange halo.
#     """
#     # Active nodes and edges
#     if mode == "simple":
#         active_ids = set(get_active_ids_simple(focus_id))
#         e = edges_rich[
#             edges_rich["source"].isin(active_ids)
#             & edges_rich["target"].isin(active_ids)
#         ]
#         base_edge_color = "rgba(156, 163, 175, 0.5)"
#         focus_edge_color = "rgba(55, 65, 81, 0.95)"
#     else:
#         active_ids = set(nodes["id"])
#         e = edges_rich
#         base_edge_color = "rgba(156, 163, 175, 0.35)"
#         focus_edge_color = "rgba(55, 65, 81, 0.85)"

#     # focus vs non-focus edges
#     edge_x_focus, edge_y_focus = [], []
#     edge_x_other, edge_y_other = [], []
#     for _, row in e.iterrows():
#         x0, y0 = pos[row["source"]]
#         x1, y1 = pos[row["target"]]
#         is_focus_edge = (
#             focus_id is not None and (row["source"] == focus_id or row["target"] == focus_id)
#         )
#         if is_focus_edge:
#             edge_x_focus += [x0, x1, None]
#             edge_y_focus += [y0, y1, None]
#         else:
#             edge_x_other += [x0, x1, None]
#             edge_y_other += [y0, y1, None]

#     other_edges_trace = go.Scatter(
#         x=edge_x_other,
#         y=edge_y_other,
#         mode="lines",
#         line=dict(width=1, color=base_edge_color),
#         hoverinfo="none",
#         showlegend=False,
#     )
#     focus_edges_trace = go.Scatter(
#         x=edge_x_focus,
#         y=edge_y_focus,
#         mode="lines",
#         line=dict(width=2.2, color=focus_edge_color),
#         hoverinfo="none",
#         showlegend=False,
#     )

#     # Node visual
#     xs, ys, colors, sizes, opacities, borders, texts, ids = [], [], [], [], [], [], [], []
#     for row in nodes.itertuples():
#         mid = row.id
#         xs.append(row.x)
#         ys.append(row.y)
#         ids.append(mid)

#         # base: background node (visible but quiet)
#         color = "#CBD5E1"   # slate-200
#         size = 8
#         opacity = 0.6
#         border = "rgba(0,0,0,0)"

#         # active nodes in simple / rich modes
#         if mid in active_ids:
#             color = row.color
#             size = row.marker_size
#             opacity = 0.95 if mode == "rich" else 0.9

#         # focus node: subtle enlargement + dark border
#         if focus_id is not None and mid == focus_id:
#             size *= 1.2
#             border = "#111827"

#         tags_text = getattr(row, "top_tags", "")
#         if not tags_text:
#             tags_text = "No tags available"

#         texts.append(
#             f"<b>{row.label}</b><br>"
#             f"Genre: {row.main_genre}<br>"
#             f"Avg rating: {row.avg_rating:.2f} / 5<br>"
#             f"Ratings: {row.rating_count}<br>"
#             f"Key tags: {tags_text}<br>"
#             f"<span style='font-size:11px;color:#6B7280;'>"
#             f"Recommendations are based on shared genres and user tags with nearby movies."
#             f"</span>"
#         )
#         colors.append(color)
#         sizes.append(size)
#         opacities.append(opacity)
#         borders.append(border)

#     node_trace = go.Scatter(
#         x=xs,
#         y=ys,
#         mode="markers",
#         hoverinfo="text",
#         text=texts,
#         marker=dict(
#             size=sizes,
#             color=colors,
#             opacity=opacities,
#             line=dict(width=2, color=borders),
#         ),
#         customdata=ids,
#         showlegend=False,
#     )

#     traces = [other_edges_trace, focus_edges_trace, node_trace]

#     # highlight for searched node: orange halo
#     if search_id is not None and search_id in nodes["id"].values:
#         srow = nodes[nodes["id"] == search_id].iloc[0]
#         halo_size = max(float(srow["marker_size"]) * 1.8, 34.0)
#         search_highlight = go.Scatter(
#             x=[srow["x"]],
#             y=[srow["y"]],
#             mode="markers",
#             marker=dict(
#                 size=halo_size,
#                 color="rgba(0,0,0,0)",
#                 line=dict(width=4, color="#F97316"),
#             ),
#             hoverinfo="skip",
#             showlegend=False,
#         )
#         traces.append(search_highlight)

#     title_text = (
#         "Movie Network – Simple Mode (Calm View)"
#         if mode == "simple"
#         else "Movie Network – Rich Mode (Deep Dive)"
#     )

#     fig = go.Figure(data=traces)
#     fig.update_layout(
#         title=title_text,
#         title_x=0.5,
#         font=dict(family="Arial, sans-serif", size=14),
#         xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
#         yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
#         plot_bgcolor="#F9FAFB",
#         paper_bgcolor="#F9FAFB",
#         hovermode="closest",
#         margin=dict(l=10, r=10, t=60, b=10),
#     )
#     return fig


# def make_rating_histogram(focus_id=None):
#     """
#     Linked histogram:
#     - When a movie is in focus (hover/click/search), bar color = node color.
#     - Otherwise, default blue.
#     """
#     if focus_id is None or focus_id not in rating_hist["movieId"].values:
#         df = rating_hist.copy()
#         title = "Rating Distribution – All Movies in Network"
#         bar_color = "#0072B2"
#     else:
#         df = rating_hist[rating_hist["movieId"] == focus_id].copy()
#         movie_row = nodes[nodes["id"] == focus_id].iloc[0]
#         movie_title = movie_row["label"]
#         bar_color = movie_row["color"]
#         title = f"Rating Distribution – {movie_title}"

#     df = df.sort_values("rating")
#     fig = go.Figure(
#         data=[
#             go.Bar(
#                 x=df["rating"],
#                 y=df["count"],
#                 marker=dict(color=bar_color),
#             )
#         ]
#     )
#     fig.update_layout(
#         title=title,
#         title_x=0.5,
#         font=dict(family="Arial, sans-serif", size=13),
#         xaxis_title="Rating (0.5 – 5.0)",
#         yaxis_title="Number of Ratings",
#         bargap=0.15,
#         plot_bgcolor="#FFFFFF",
#         paper_bgcolor="#F9FAFB",
#         margin=dict(l=40, r=20, t=60, b=40),
#     )
#     return fig


# # Dash

# app = Dash(__name__)
# server = app.server  # for Render

# app.layout = html.Div(
#     style={
#         "fontFamily": "Arial, sans-serif",
#         "padding": "12px 18px",
#         "backgroundColor": "#F3F4F6",
#     },
#     children=[
#         # Store to persist locked focus + last search
#         dcc.Store(
#             id="focus-store",
#             data={"locked_focus_id": None, "last_search_id": None},
#         ),

#         html.Div(
#             [
#                 html.H2(
#                     "Neurodiversity-Friendly Movie Explorer",
#                     style={"marginBottom": "4px"},
#                 ),
#                 html.Div(
#                     "Explore movies by emotional and genre similarity. Simple Mode shows a small, calm neighborhood; Rich Mode reveals the full network.",
#                     style={"color": "#4B5563", "fontSize": "14px"},
#                 ),
#             ],
#             style={"marginBottom": "10px"},
#         ),

#         # Controls row
#         html.Div(
#             [
#                 html.Span("Display Mode:", style={"marginRight": "8px"}),
#                 dcc.RadioItems(
#                     id="mode-toggle",
#                     options=[
#                         {"label": " Simple (Calm View)", "value": "simple"},
#                         {"label": " Rich (Deep Dive)", "value": "rich"},
#                     ],
#                     value="simple",
#                     inline=True,
#                     style={"fontSize": "14px"},
#                 ),
#                 html.Span("  |  ", style={"margin": "0 8px"}),
#                 dcc.Dropdown(
#                     id="search-dropdown",
#                     options=[
#                         {"label": row["label"], "value": int(row["id"])}
#                         for _, row in nodes.sort_values("label").iterrows()
#                     ],
#                     placeholder="Search for a movie…",
#                     style={"width": "280px", "display": "inline-block"},
#                 ),
#                 html.Button(
#                     "Reset View",
#                     id="reset-view",
#                     n_clicks=0,
#                     style={
#                         "marginLeft": "10px",
#                         "padding": "4px 10px",
#                         "borderRadius": "6px",
#                         "border": "1px solid #D1D5DB",
#                         "backgroundColor": "#FFFFFF",
#                         "cursor": "pointer",
#                     },
#                 ),
#             ],
#             style={
#                 "marginBottom": "8px",
#                 "padding": "6px 10px",
#                 "backgroundColor": "#FFFFFF",
#                 "borderRadius": "8px",
#                 "boxShadow": "0 1px 3px rgba(0,0,0,0.06)",
#             },
#         ),

#         # two-panel view
#         html.Div(
#             [
#                 html.Div(
#                     [
#                         dcc.Graph(
#                             id="network-graph",
#                             figure=make_network_figure(
#                                 mode="simple", focus_id=None, search_id=None
#                             ),
#                             style={"height": "620px"},
#                             config={"displayModeBar": True},
#                         )
#                     ],
#                     style={
#                         "width": "65%",
#                         "display": "inline-block",
#                         "verticalAlign": "top",
#                     },
#                 ),
#                 html.Div(
#                     [
#                         dcc.Graph(
#                             id="histogram",
#                             figure=make_rating_histogram(focus_id=None),
#                             style={"height": "620px"},
#                             config={"displayModeBar": True},
#                         )
#                     ],
#                     style={
#                         "width": "34%",
#                         "display": "inline-block",
#                         "verticalAlign": "top",
#                         "marginLeft": "1%",
#                     },
#                 ),
#             ]
#         ),

#         # legend + explanation
#         html.Div(
#             [
#                 html.H4("What this network shows", style={"marginBottom": "4px"}),
#                 html.P(
#                     "Each circle is a movie. Lines show similarity based on shared genres and overlapping user tags "
#                     "(which often describe mood or emotional themes).",
#                     style={"marginBottom": "6px"},
#                 ),
#                 html.P(
#                     "This network supports tasks like: "
#                     "(1) finding similar movies from one you already enjoy, "
#                     "(2) discovering nearby genres, and "
#                     "(3) comparing how strongly related different recommendations are.",
#                     style={"marginBottom": "10px"},
#                 ),
#                 html.Div(
#                     [
#                         # LEFT COLUMN: legend + genre colors
#                         html.Div(
#                             [
#                                 html.Div(
#                                     "Visual legend",
#                                     style={
#                                         "fontWeight": "bold",
#                                         "marginBottom": "4px",
#                                     },
#                                 ),
#                                 html.Ul(
#                                     [
#                                         html.Li(
#                                             "Colored node = movie in the current focus area "
#                                             "(up to 10 neighbors in Simple Mode; all movies in Rich Mode)."
#                                         ),
#                                         html.Li(
#                                             "Small grey node = other movies in the dataset "
#                                             "(background context so you never explore in the dark)."
#                                         ),
#                                         html.Li(
#                                             "Node size = how many ratings the movie received "
#                                             "(audience engagement)."
#                                         ),
#                                         html.Li(
#                                             "Lines = similarity based on shared genres and shared tags."
#                                         ),
#                                     ],
#                                     style={
#                                         "paddingLeft": "18px",
#                                         "marginBottom": "6px",
#                                     },
#                                 ),
#                                 html.Div(
#                                     "Genre colors:",
#                                     style={
#                                         "fontWeight": "bold",
#                                         "marginTop": "6px",
#                                     },
#                                 ),
#                                 html.Div(
#                                     [
#                                         html.Div(
#                                             [
#                                                 html.Span(
#                                                     style={
#                                                         "display": "inline-block",
#                                                         "width": "10px",
#                                                         "height": "10px",
#                                                         "borderRadius": "2px",
#                                                         "backgroundColor": genre_color_map[g],
#                                                         "marginRight": "4px",
#                                                     }
#                                                 ),
#                                                 html.Span(g),
#                                             ],
#                                             style={"marginTop": "2px"},
#                                         )
#                                         for g in unique_genres
#                                     ]
#                                 ),
#                             ],
#                             style={"flex": "1", "marginRight": "20px"},
#                         ),
#                         # RIGHT COLUMN: interaction guide
#                         html.Div(
#                             [
#                                 html.Div(
#                                     "How to interact",
#                                     style={
#                                         "fontWeight": "bold",
#                                         "marginBottom": "4px",
#                                     },
#                                 ),
#                                 html.Ul(
#                                     [
#                                         html.Li(
#                                             "Hover a movie: see its details and tags, and update the rating histogram color, "
#                                             "but the camera does not move."
#                                         ),
#                                         html.Li(
#                                             "Click a movie: lock focus on it and gently recenter/zoom in. "
#                                             "After that, hover will not change the focus until you click/search/reset."
#                                         ),
#                                         html.Li(
#                                             "Search for a movie: jump to it, lock focus, and highlight it with an orange halo."
#                                         ),
#                                         html.Li(
#                                             "Use Simple Mode for a calmer view with at most 10 colorful nodes; "
#                                             "use Rich Mode to see the full similarity network."
#                                         ),
#                                         html.Li(
#                                             "Use the toolbar or the Reset View button (top) to return to the full overview "
#                                             "and clear the current focus."
#                                         ),
#                                     ],
#                                     style={"paddingLeft": "18px"},
#                                 ),
#                             ],
#                             style={"flex": "1"},
#                         ),
#                     ],
#                     style={"display": "flex", "flexDirection": "row"},
#                 ),
#             ],
#             style={
#                 "marginTop": "12px",
#                 "padding": "10px 12px",
#                 "backgroundColor": "#FFFFFF",
#                 "borderRadius": "8px",
#                 "boxShadow": "0 1px 3px rgba(0,0,0,0.06)",
#                 "fontSize": "13px",
#                 "color": "#374151",
#             },
#         ),
#     ],
# )


# # hover + click + search + reset (with focus lock + stable zoom)

# @app.callback(
#     Output("network-graph", "figure"),
#     Output("histogram", "figure"),
#     Output("focus-store", "data"),
#     Input("mode-toggle", "value"),
#     Input("network-graph", "hoverData"),
#     Input("network-graph", "clickData"),
#     Input("search-dropdown", "value"),
#     Input("reset-view", "n_clicks"),
#     State("focus-store", "data"),
#     State("network-graph", "figure"),
# )
# def update(mode, hoverData, clickData, search_value, reset_clicks, focus_store, current_fig):
#     ctx = callback_context
#     prop_id_full = ctx.triggered[0]["prop_id"] if ctx.triggered else ""
#     prop_id = prop_id_full.split(".")[0] if prop_id_full else ""

#     # previous state
#     locked_focus_id = None
#     last_search_id = None
#     if isinstance(focus_store, dict):
#         locked_focus_id = focus_store.get("locked_focus_id", None)
#         last_search_id = focus_store.get("last_search_id", None)

#     focus_id = None
#     center_id = None
#     search_id_for_halo = last_search_id

#     if prop_id == "reset-view":
#         # Full reset: no lock, no search, global
#         locked_focus_id = None
#         last_search_id = None
#         focus_id = None
#         center_id = None
#         search_id_for_halo = None

#     elif prop_id == "search-dropdown":
#         # Search: lock focus to searched movie
#         locked_focus_id = search_value
#         last_search_id = search_value
#         focus_id = search_value
#         center_id = search_value
#         search_id_for_halo = search_value

#     elif prop_id == "network-graph" and prop_id_full.endswith("clickData"):
#         # Click: lock focus to clicked movie, keep last search halo if any
#         if clickData and "points" in clickData:
#             clicked_id = clickData["points"][0].get("customdata", None)
#             locked_focus_id = clicked_id
#             focus_id = clicked_id
#             center_id = clicked_id
#         search_id_for_halo = last_search_id

#     elif prop_id == "network-graph" and prop_id_full.endswith("hoverData"):
#         # Hover:
#         #  - if there is a locked focus, keep using it (hover only changes tooltip)
#         #  - if no locked focus, use hovered as focus
#         if locked_focus_id is not None:
#             focus_id = locked_focus_id
#             center_id = None  # NEVER recenter on hover
#         else:
#             if hoverData and "points" in hoverData:
#                 hover_id = hoverData["points"][0].get("customdata", None)
#                 focus_id = hover_id
#             center_id = None
#         search_id_for_halo = last_search_id

#     else:
#         # Initial or other triggers: respect locked focus if present
#         focus_id = locked_focus_id
#         center_id = None
#         search_id_for_halo = last_search_id

#     # Build network figure
#     fig_network = make_network_figure(
#         mode=mode,
#         focus_id=focus_id,
#         search_id=search_id_for_halo,
#     )

#     # Camera ranges
#     if prop_id == "reset-view":
#         x_range, y_range = GLOBAL_X_RANGE, GLOBAL_Y_RANGE
#     elif center_id is not None:
#         # recentre once on click or search
#         x_range, y_range = compute_centered_axis_ranges(center_id)
#     else:
#         # keep whatever range the user is currently at (no jump on hover)
#         if current_fig and "layout" in current_fig:
#             layout = current_fig.get("layout", {})
#             x_range = layout.get("xaxis", {}).get("range", GLOBAL_X_RANGE)
#             y_range = layout.get("yaxis", {}).get("range", GLOBAL_Y_RANGE)
#         else:
#             x_range, y_range = GLOBAL_X_RANGE, GLOBAL_Y_RANGE

#     fig_network.update_layout(
#         xaxis=dict(range=x_range),
#         yaxis=dict(range=y_range),
#         transition=dict(duration=450),
#     )

#     # histogram
#     fig_hist = make_rating_histogram(focus_id=focus_id)

#     # Updated store
#     new_store = {
#         "locked_focus_id": locked_focus_id,
#         "last_search_id": last_search_id,
#     }
#     return fig_network, fig_hist, new_store


# if __name__ == "__main__":
#     app.run_server(debug=True)

